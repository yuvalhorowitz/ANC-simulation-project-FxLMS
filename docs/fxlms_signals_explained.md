# FxLMS Signal Notation Explained

**Common Misconception Clarified**

This document clarifies a common point of confusion about FxLMS signal notation, specifically why x'(n) is filtered through the secondary path Ŝ(z) and not the primary path P(z).

---

## The Confusion

**Initial assumption (incorrect):**
> "x'(n) should represent the noise when it reaches the ear after going through the primary path"

**Reality:**
> x'(n) is a mathematical construct for the gradient calculation, not a physical signal path representation.

---

## Signal Definitions

| Signal | Definition | Physical Meaning |
|--------|------------|------------------|
| **n(t)** | Noise source | Original noise (engine, road, wind) |
| **x(n)** | Reference mic output | Noise picked up near source |
| **d(n)** | P(z) * n(t) | **Noise at ear after primary path** |
| **y(n)** | W(z) * x(n) | Anti-noise generated by filter |
| **y'(n)** | S(z) * y(n) | Anti-noise at ear after secondary path |
| **e(n)** | d(n) + y'(n) | Residual error at error mic |
| **x'(n)** | Ŝ(z) * x(n) | **Filtered reference for gradient** (mathematical) |

---

## Key Insight: d(n) Is What You Were Thinking Of

The signal representing "noise at the ear after the primary path" **does exist** - it's called **d(n)**, not x'(n).

```
Noise source ──→ [P(z) Primary Path] ──→ d(n) at ear
```

---

## Why We Don't Need to Compute d(n)

We measure **e(n) directly** at the error microphone:

```
e(n) = d(n) + y'(n)
       ↑       ↑
       │       └── anti-noise at ear (we control this)
       └── noise at ear (we don't need to compute separately)
```

The error mic captures the **sum** of noise and anti-noise. We don't need to separate them.

---

## Why x'(n) Uses Secondary Path Ŝ(z)

### The Mathematical Reason

**Goal:** Minimize error power E[e²(n)] by adjusting filter weights W.

**LMS weight update:**
```
w(n+1) = w(n) - μ · ∂e²(n)/∂W
```

**Computing the gradient:**
```
∂e²(n)/∂W = 2 · e(n) · ∂e(n)/∂W
```

**The key derivative:**
```
e(n) = d(n) + y'(n)
     = d(n) + S(z) · W(z) · x(n)

∂e(n)/∂W = S(z) · x(n)    ← Secondary path appears here!
```

**Therefore, the correct update is:**
```
w(n+1) = w(n) + μ · e(n) · [Ŝ(z) · x(n)]
                            └── x'(n)
```

### The Intuitive Reason

When you change the filter weights W:

1. y(n) changes (filter output)
2. y(n) travels through **secondary path S(z)** to the speaker to the ear
3. y'(n) changes at the error mic
4. e(n) changes

The **sensitivity of e(n) to W** depends on **S(z)**, because that's the path the anti-noise takes.

The primary path P(z) doesn't affect this sensitivity because changing W doesn't affect d(n).

---

## Visual Comparison

### Physical Signal Flow
```
                                        ┌─────────────────┐
Noise ──────────→ [P(z)] ──────→ d(n) ─→│                 │
source            primary        noise  │   ERROR MIC     │──→ e(n)
                  path           at ear │   measures      │
                                        │  e(n)=d(n)+y'(n)│
Ref mic ──→ [W(z)] ──→ Speaker ─→[S(z)]→│                 │
 x(n)       filter              secondary└─────────────────┘
                                path   y'(n)
                                       anti-noise at ear
```

### Gradient Calculation (Mathematical)
```
x(n) ──→ [Ŝ(z)] ──→ x'(n) ──→ [× e(n)] ──→ [× μ] ──→ Δw
         estimate    filtered    error      step     weight
         of S(z)     reference   signal     size     update
```

---

## Common Misconception vs Reality

### Wrong Mental Model
```
"x'(n) represents x(n) after traveling through some path"

x(n) ──→ [P(z)?] ──→ x'(n)?   ← INCORRECT
```

### Correct Mental Model
```
"x'(n) is x(n) adjusted for gradient calculation using Ŝ(z)"

x(n) ──→ [Ŝ(z)] ──→ x'(n)     ← CORRECT (for gradient math)
```

---

## Why Not Use P(z) for Filtering?

If we incorrectly used x'(n) = P̂(z) * x(n):

1. **Wrong gradient direction** - The update would push W in the wrong direction
2. **No convergence** - The algorithm would fail to minimize error
3. **Possible instability** - The filter could diverge

The math requires S(z) because that's the path between W's output and the error signal.

---

## The Name "Filtered-x LMS"

The algorithm is called **Filtered-x LMS** because:

| Algorithm | Update Rule |
|-----------|-------------|
| Standard LMS | `w += μ · e(n) · x(n)` |
| **Filtered-x LMS** | `w += μ · e(n) · x'(n)` where `x'(n) = Ŝ(z) * x(n)` |

The "filtered" refers to filtering x(n) through the secondary path estimate Ŝ(z).

---

## Summary

| Question | Answer |
|----------|--------|
| What represents noise at the ear? | **d(n)** = P(z) * noise |
| What is x'(n)? | Mathematical term for gradient: x'(n) = Ŝ(z) * x(n) |
| Why secondary path for x'(n)? | Because gradient ∂e/∂W involves S(z), not P(z) |
| Do we need to estimate d(n)? | No, we measure e(n) = d(n) + y'(n) directly |
| What if we used P(z) instead? | Algorithm would not converge correctly |

---

## Practical Implication

In your simulation code (`src/core/fxlms.py`):

```python
def filter_reference(self, x):
    """
    Filter reference signal through secondary path estimate.

    This is x'(n) = Ŝ(z) * x(n)
    Used for gradient calculation, NOT for estimating noise at ear.
    """
    self.x_buffer = np.roll(self.x_buffer, 1)
    self.x_buffer[0] = x
    return np.dot(self.secondary_path_estimate, self.x_buffer)

def update_weights(self, e):
    """
    LMS weight update using filtered reference.

    w(n+1) = w(n) + μ · e(n) · x'(n)

    The x'(n) term comes from the gradient ∂e/∂W = S(z) · x(n)
    """
    self.weights += self.step_size * e * self.x_filtered_buffer
```

---

## References

- Widrow, B., & Stearns, S. D. (1985). Adaptive Signal Processing. Prentice-Hall.
- Kuo, S. M., & Morgan, D. R. (1996). Active Noise Control Systems. Wiley.
- Elliott, S. J. (2001). Signal Processing for Active Control. Academic Press.

---

**Document created:** January 2025
**Purpose:** Clarify common FxLMS notation confusion
